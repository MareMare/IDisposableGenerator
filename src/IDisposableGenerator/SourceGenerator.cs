// --------------------------------------------------------------------------------------------------------------------
// <copyright file="SourceGenerator.cs" company="MareMare">
// Copyright © 2022 MareMare. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// --------------------------------------------------------------------------------------------------------------------

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace IDisposableGenerator;

[Generator(LanguageNames.CSharp)]
public class SourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource(
                "GenerateIDisposableAttribute.cs",
                """
// <auto-generated />
namespace IDisposableGenerator;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class GenerateIDisposableAttribute : Attribute
{
}               
""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "IDisposableGenerator.GenerateIDisposableAttribute",
            static (node, token) => true,
            static (context, token) => context);

        context.RegisterSourceOutput(source, SourceGenerator.Emit);
    }

    private static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;

        if (typeSymbol.GetMembers("Dispose").Length != 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.DisposeMethodAlreadyExists,
                typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {typeSymbol.ContainingNamespace};";

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        var code = $$"""
// <auto-generated />
#nullable enable

using System;

{{ns}}

partial class {{typeSymbol.Name}} : IDisposable
{
    /// <summary><see cref="IDisposable.Dispose" /> メソッドが呼び出されたかをスレッドセーフで管理する値を表します。</summary>
    private long _disposableState;

    /// <summary>
    /// <see cref="{{typeSymbol.Name}}" /> クラスのインスタンスが GC に回収される時に呼び出されます。
    /// </summary>
    ~{{typeSymbol.Name}}()
    {
        this.Dispose(false);
    }

    /// <summary>
    /// <see cref="IDisposable.Dispose" /> されたかを取得します。
    /// </summary>
    /// <value>
    /// 値を表す <see cref="bool" /> 型。
    /// <para><see cref="IDisposable.Dispose" /> された場合 true。既定値は false です。</para>
    /// </value>
    public bool IsDisposed => Interlocked.Read(ref this._disposableState) == 1L;

    /// <summary>
    /// アンマネージ リソースの解放およびリセットに関連付けられているアプリケーション定義のタスクを実行します。
    /// </summary>
    public void Dispose()
    {
        this.Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// <see cref="{{typeSymbol.Name}}" /> クラスのインスタンスによって使用されているアンマネージ リソースを解放し、オプションでマネージ リソースも解放します。
    /// </summary>
    /// <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は true。アンマネージ リソースだけを解放する場合は false。</param>
    protected virtual void Dispose(bool disposing)
    {
        if (Interlocked.CompareExchange(ref this._disposableState, 1L, 0L) == 0L)
        {
            if (disposing)
            {
                // マネージ リソース (IDisposable の実装インスタンス) の解放処理をこの位置に記述します。
                DisposeManagedInstances();
            }

            // アンマネージ リソース (IDisposable の非実装インスタンス) の解放処理をこの位置に記述します。
            DisposeUnmanagedInstances();
        }
    }

    /// <summary>
    /// マネージ リソースを解放します。
    /// </summary>
    partial void DisposeManagedInstances();

    /// <summary>
    /// アンマネージ リソースを解放します。
    /// </summary>
    partial void DisposeUnmanagedInstances();
}
""";
        context.AddSource($"{fullType}.IDisposableGenerator.g.cs", code);
    }
}
